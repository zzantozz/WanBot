package org.wanbotimport groovy.util.XmlNodePrinterimport java.lang.NumberFormatExceptionimport groovy.util.ProxyGeneratorimport javax.mail.*;
import javax.mail.search.SearchTerm;
import javax.mail.event.*;
import org.apache.log4j.Loggerclass WanBot {        def log = Logger.getLogger("org.wanbot.assignments")        // These are destructive. Don't run tests on them until I find a better way.
    def doAssignment(assigner, assignee, points) {        logAssignment(assigner, assignee, points)        updateDataFile(assignee, points)    }        def updateDataFile(peepName, addPoints) {        println '  updating with ' + peepName + ', ' + addPoints
        def xml = new File("datastore.xml").getText()
        xml = updateXml(xml, peepName, addPoints)
        new PrintWriter(new FileWriter(datafile)).print(xml)
    }    
    def doWithMessages(cmd) {        Session session = Session.getDefaultInstance(System.getProperties())        Store store = session.getStore("pop3s")        store.connect('pop.gmail.com', 995, credentials().user, credentials().password)        Folder folder = store.getDefaultFolder().getFolder("INBOX")        folder.open(Folder.READ_ONLY)        folder.getMessages().each(cmd)        folder.close(false)        store.close()    }        def logAssignment(assigner, points, assignee){        log.debug(assigner + ' -> ' + points + ' -> ' + assignee)    }        // The rest is non-destructive. Test away.    def handleMessageAssignments(assigner, assignments, assignmentStorer) {        assignments.each{ assignment ->            def assignee = assignment[0]            def points = assignment[1]            if (points > 0 && points <= 10) {                assignmentStorer(assigner, assignee, points)            } else {                println 'Points out of bounds, not adding to datastore'            }        }    }        def dissectMailMessage(message, pointsFinder) {        if (message.getFrom().length > 1) {            println 'WARNING: More than one sender listed in "from" field'         }        def sender = message.getFrom()[0].getAddress()        def messageText = findMessageTextInMessage(message)        def assignments = pointsFinder(messageText)        return [sender, assignments]    }    
    def findMessageTextInMessage(message) {
        def result        if (message.getContent() instanceof Multipart) {            result = findMessageTextInMultipartMessageContent(message.getContent())        } else {            result = message.getContent()        }
        return result    }        def findMessageTextInMultipartMessageContent(content) {        def result        for (i in 0..content.getCount() - 1) {            def part = content.getBodyPart(i)            if (part.contentType.contains('text/plain')) {                result = part.content                break            }        }        return result    }        def updateXml(xml, peepName, addPoints) {
        def thewan = new XmlParser().parseText(xml)        addPointsToXml(thewan, peepName, addPoints)
        def result = new StringWriter()        new XmlNodePrinter(result).print(thewan)
        return result.toString()    }        def addPointsToXml(thewan, peepName, addPoints) {        def peepNode = findPeep(thewan, peepName)        def pointsNode        if (peepNode == null) {            peepNode = thewan.peeps[0].appendNode('peep', [name: peepName])            pointsNode = thewan.points[0].appendNode('peep', [name: peepName, points: 0])        } else {            pointsNode = thewan.points.peep.find{ it.@name.equals(peepNode.@name) }        }        pointsNode.@points = pointsNode.@points.toInteger() + addPoints    }        def findPeep(records, peepName) {        return records.peeps.peep.find{ it.@name.equals(peepName) || it.alias.text().equals(peepName) }    }
    
    def credentials() {        def props = new Properties()        props.load(getClass().getResourceAsStream("/wanbot.properties"))        return [ user:props.getProperty('user'), password:props.getProperty('password') ]    }
    
    def findPointAssignmentsInMessageText(text) {        def allMatches = []        def regex = /(?m)^([A-Za-z]+?):?\ \+?(?:gets\ |earns\ )?(\d+)\ ?(?:points|pts|point|pt)?/        addMatchesFromRegex(text, regex, allMatches, 1, 2)        regex = /(?m)^\+?(\d+)\ ?(?:points|pts|point|pt)?\ (?:for\ )?([A-Za-z]+)/        addMatchesFromRegex(text, regex, allMatches, 2, 1)        return allMatches    }        def addMatchesFromRegex(text, regex, allMatches, nameGroup, pointGroup) {        def regexMatches = (text =~ regex)        regexMatches.each{ match ->            try {                allMatches << [match[nameGroup], match[pointGroup].toInteger()]            } catch (e) {                println '  skipping out-of-bounds number: ' + groups[pointGroup]            }        }    }        def uniqifyPointAssignments(assignments) {        def map = [:]        assignments.each{ map.put(it[0], it[1]) }        def result = []        map.each{ k, v -> result << [k, v] }        return result    }    def withWanFilter(mailMessage, mailMessageProcessor) {        def to = mailMessage.getAllRecipients()[0].toString()        def condition = to.toLowerCase().contains("white_and_nerdy@googlegroups.com")        if (condition) {            mailMessageProcessor(mailMessage)        } else {            println 'Skipping non-WaN message'        }    }}